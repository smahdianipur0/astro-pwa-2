---
import Card from "../components/Card.astro";

---

<div style="
display: flex; 
flex-direction: column; 
align-items: center; 
gap: var(--gap-x04); 
margin-inline: var(--gap-x04)
height: 85%;
overflow-y: scroll;
padding-top: var(--gap-x02);
padding-inline: var(--gap-x02);">

  <Card iden="entries-list-card" >
    <div style="display: flex; flex-direction: column;" class="prose" id="input-group">
      <input type="text" id="title-input" placeholder="Title" style="margin-bottom: var(--gap-x03);"/>
      <div style="display: flex; flex-direction: row;">
        <input id="auto-pass-entry" type="checkbox" style="
        margin-top: var(--gap-x03); 
        margin-bottom: var(--gap-x03);"> 
        <label style="
        place-self: center; 
        margin-left: var(--gap);
        margin-top: var(--gap-x03);
        margin-bottom: var(--gap-x03);" for="auto-pass-entry">Enter Password Manually</label>
      </div>
      <input type="text" id="password-input" placeholder="Password" readonly />
      
      <button style="margin-top: var(--gap-x03);"id="add-entry-button">Add</button>
    </div>
  </Card>

  <div class="entries-list" id="entries-list"></div>


</div>


<script>

import {
	createPasswordEntry,
	getAllPasswordEntries,
	deletePasswordEntry,
	type PasswordEntry,} from "../utils/surrealdb";
import { element } from '../utils/elementUtils';
import { password, showToast } from "../components/signals.ts";
import { createSignal, createEffect } from "solid-js";



// signals
const [listTitle, setListTitle]       = createSignal('')
const [listPassword, setListPassword] = createSignal('');
const [listEntries, setListEntries]   = createSignal<PasswordEntry[]>([]);


// initialize entries
(async () => {setListEntries(await getAllPasswordEntries() ?? []);})();

createEffect(() => { setListPassword(password()) });


// await elements
(async () => {
	// Remove the blinking animation when JS loads
	const drawerTrigger = await element.wait("#drawer-trigger");
	drawerTrigger.style.animation = 'none';

	const inputGroup     = (await element.wait("#input-group"))    as HTMLElement;
	const entriesList    = (await element.wait("#entries-list"))   as HTMLElement;
	const passwordInput  = (await element.wait("#password-input"))  as HTMLInputElement;
	const titleInput     = (await element.wait("#title-input"))     as HTMLInputElement;
	const addEntryButton = (await element.wait("#add-entry-button")) as HTMLButtonElement;


// render entries based on signal
createEffect(() => {
	entriesList.textContent = '';
	const fragment = document.createDocumentFragment();
  
	(listEntries() ?? []).reverse().forEach((entry) => {
		fragment.append(
			element.configure(document.createElement('div'), {
				className: 'entry-item',
				append: [
					element.configure(document.createElement('div'), {
						append: [
							element.configure(document.createElement('p'), {
								className: 'hint',
								textContent: entry.title || 'untitled'
							}),
							element.configure(document.createElement('button'), {
								className: 'copy-button',
								id: entry.password ?? '',
								textContent: entry.password ?? ''
							})
						]
					}),
					element.configure(document.createElement('div'), {
						className: 's-container',
						append: [
							element.configure(document.createElement('details'), {
								name: 'delete-item',
								append: [
									document.createElement('summary'),
									element.configure(document.createElement('button'), {
										className: 'delete-button',
										id: entry.id?.id ?? '',
										textContent: ' Delete'
									})
								]
							})
						]
					})
				]
			})
		);
	});
  
	entriesList.append(fragment);
  });

  // delete entry
	entriesList.addEventListener("click", (e) => {
		const deleteButton = (e!.target as HTMLInputElement).closest(".delete-button");
		if (deleteButton) {
			(async () => {
				await deletePasswordEntry(deleteButton.id);
				setListEntries((await getAllPasswordEntries()) ?? []);
			})();
		}
    
    const copyButton = (e!.target as HTMLInputElement).closest(".copy-button");
		if (copyButton) {
			(async () => {
				navigator.clipboard.writeText(copyButton.id);  
         showToast();
			})();
		}
	});

  // add entry
	inputGroup.addEventListener("click", (e) => {
		if ((e!.target as HTMLInputElement).matches("#add-entry-button")) {
			(async () => {
				await createPasswordEntry(listTitle(), listPassword());
				setListTitle("");
        if ((document.getElementById("auto-pass-entry") as HTMLInputElement).checked){
				  setListPassword("");
				}
				setListEntries((await getAllPasswordEntries()) ?? []);
			})();
		}

    // auto-pass entry
    if ((e!.target as HTMLInputElement).matches("#auto-pass-entry")) {
      if ((e.target as HTMLInputElement).checked) {
         (document.getElementById("password-input")! as HTMLInputElement).readOnly = false;
         setListPassword('');
      } else {
        (document.getElementById("password-input")! as HTMLInputElement).readOnly = true;
        createEffect(() => {
          setListPassword(password());
        });
      }
   }
	});

  // bind input values to signals
  inputGroup.addEventListener("input", (e) => {
    if ((e!.target as HTMLInputElement).matches("#title-input")) {
      setListTitle((e!.target as HTMLInputElement).value);
    } else if ((e!.target as HTMLInputElement).matches("#password-input")) {
      setListPassword((e!.target as HTMLInputElement).value);
    }
  });


	// bind signals to input values
	createEffect(() => {
		titleInput.value = listTitle();
	});

	createEffect(() => {
		passwordInput.value = listPassword();
	});


	// update add entry button state
	createEffect(() => {
		if (!listPassword()) {
			addEntryButton.disabled = true;
		} else {
			addEntryButton.disabled = false;
		}
	});

})();

</script>


<style is:global>
  .entries-list{
    display: flex;
    flex-direction: column;
    width: 100%;
    align-items: center;
  }
  
  .entry-item{
    display: flex;
    place-content: space-between;
    width: min(100%, 65ch);
    background-color: oklch(var(--gray-15) / 1);
    border-radius: 0;
    padding: var(--default-padding);
    margin: 0 var(--gap);
    position: relative;
  }

  .entries-list > :first-child{
    border-top-left-radius: var(--radius-b);
    border-top-right-radius: var(--radius-b);
    margin-top: var(--gap);
  }

  .entries-list > :last-child{
    border-bottom-left-radius: var(--radius-b);
    border-bottom-right-radius: var(--radius-b);
    margin-bottom: var(--gap-x06);
  }

  .entries-list > :last-child::after{
    content: 'tap on passwords to copy';
    position: absolute;
    bottom: 0;
    transform: translateY(var(--gap-x06));
    font-size: var(--small-font);
    color: oklch(var(--gray-50) / 1);
  }

  .entries-list > :not(:last-child){
    border-bottom:1px solid oklch(var(--gray-25) / 1);
  }

  .s-container  {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  }

details {
  margin: 0;
  position: relative;
  display: inline-block;
}

details summary::-webkit-details-marker {
  display: none;
}

summary {
  display: flex;
  position: relative;
  cursor: pointer;
  user-select: none;
  min-width: max-content;
  align-items: center;
}

@keyframes details-show {
  from {
    opacity: 0;
    transform: translateY(-50%) translateX(var(--gap-x02));
  }
  to {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }
}

details[open] > *:not(summary) {
  animation: details-show 150ms ease-in-out forwards;
}

summary::before {
  content: '🗑️';
  color: var(--danger);
  font-size: 100%;
}

details[open] > summary::before {
  content: 'Cancel';
  color: oklch(var(--gray-95) / 1);
  font-size: var(--small-font);
}

details[open] > .s-container {
  width: 10ch;
}



.delete-button {
  margin-inline: var(--gap);
  color: var(--danger);
  font-size: var(--small-font);
}

details[open] .delete-button {
  position: absolute;
  right: 100%;
  top: 50%;
  transform: translateY(-50%);
  margin-right: var(--gap);
}

@keyframes blink {
  0% { opacity: 20%; }
  50% { opacity: 60%; }
  100% { opacity: 20%; }
}

#drawer-trigger {
  opacity: 100%;
  animation: blink 1s ease-in-out infinite;
}

</style>